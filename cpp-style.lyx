#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass LyXBook--Default
\use_default_options true
\begin_removed_modules
Endnote
\end_removed_modules
\maintain_unincluded_children false
\language russian
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman Calibri Light
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format pdf4
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\paperwidth 6in
\paperheight 9in
\leftmargin 1in
\bottommargin 1.25in
\secnumdepth 1
\tocdepth 1
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle headings
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
C++ style guidelines
\end_layout

\begin_layout Subtitle
v0.01
\end_layout

\begin_layout Author
yuyoyuppe
\end_layout

\begin_layout Epigraph
Для удобства в конце приведён пример кода, аггрегирующий большинство правил
 и позволяющий быстро вспомнить правила без избыточного чтения.
\end_layout

\begin_layout Chapter
TDD
\end_layout

\begin_layout Section
Юнит-тесты и TDD
\end_layout

\begin_layout Itemize
Каждый тест содержит только одну assert-конструкцию
\end_layout

\begin_layout Itemize
Лёгкость читаемости тестов должна быть сопоставима с обычным текстом; приоритет,
 как и всегда, отдаётся наилучшему выражению intention'а
\end_layout

\begin_layout Itemize
Тесты не могут быть длиннее нескольких строк 
\end_layout

\begin_layout Itemize
Тесты не могут содержать условные конструкции — для предотвращения можно
 воспользоваться подобным кодом: 
\begin_inset listings
inline false
status open

\begin_layout Itemize

#define if(a) ERROR__cannot_use_conditional_statement_in_a_test_file;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Тесты должны быть в форме Arrange-Act-Assert
\begin_inset Foot
status open

\begin_layout Plain Layout
иногда зовётся given-when-then
\end_layout

\end_inset

, т.е.
 подготовка состояния - выполнение теста - проверка утверждения
\end_layout

\begin_layout Itemize
Предпочтительные библиотеки: mocking — fakeit, DI — boost.DI, Testing — boost.test
\end_layout

\begin_layout Itemize
Тесты пишутся 
\series bold
до 
\series default
кода, при этом каждый новый тест изначально должен проваливаться; после
 создания 
\series bold
минимально
\series default
 работающей реализации для прохождения этого теста проводится рефакторинг
 кода
\begin_inset Foot
status open

\begin_layout Plain Layout
эти три фазы составляют канонический TDD-цикл, длящийся ~10 минут
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Каждый тест служит документацией к классу, т.к.
 характеризует отдельную feature, и, благодаря написанию тестов до кода,
 мы автоматически покрываем все features, получая 100% code coverage
\begin_inset Foot
status open

\begin_layout Plain Layout
придерживаясь данной практики, надобность в специальных утилитах, позволяющих
 численно оценить code coverage, отпадает, т.к.
 не нужно полагаться на малоосмысленные цифры
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Все тесты должны выполняться не более, чем за пару секунд, иначе возникнет
 соблазн частично их отключать
\end_layout

\begin_layout Chapter
Форматирование 
\end_layout

\begin_layout Itemize
Максимальная длина строки - 110
\begin_inset Foot
status open

\begin_layout Plain Layout
аргумент 
\begin_inset Quotes fld
\end_inset

80 символов на консоли
\begin_inset Quotes frd
\end_inset

 неактуален, т.к.
 её обычно расширяют, а 100 символов Dejavu Mono 12 занимают ~1050 пикселей,
 что 
\begin_inset Quotes fld
\end_inset

должно хватить всем
\begin_inset Quotes frd
\end_inset


\end_layout

\end_inset

 символов
\end_layout

\begin_layout Itemize
Пробелы вместо табуляций
\end_layout

\begin_layout Itemize
Ширина отступа - 4 пробела
\end_layout

\begin_layout Itemize
Открывающая фигурная скобка всегда идёт на отдельной строке 
\end_layout

\begin_layout Itemize

Конструкция switch-case выглядит так:
\lang russian

\begin_inset listings
inline false
status open

\begin_layout Plain Layout

switch(condition)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	case 1:
\end_layout

\begin_layout Plain Layout

	// ...
\end_layout

\begin_layout Plain Layout

	break;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	case 2:
\end_layout

\begin_layout Plain Layout

	// ...
\end_layout

\begin_layout Plain Layout

	break;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	default:
\end_layout

\begin_layout Plain Layout

	// ...
\end_layout

\begin_layout Plain Layout

	break;
\end_layout

\begin_layout Plain Layout

}   
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Допускается использование однострочных блоков if-else без фигурных скобок
 для повышения читаемости
\end_layout

\begin_layout Itemize
Комментарии пишутся предыдущей строкой(а не продолжением) перед релевантным
 кодом на одном с ним уровне отступа
\end_layout

\begin_layout Itemize
Одна строка - одно объявление
\end_layout

\begin_layout Itemize
Если аргументы не помещаются в вызов/объявление, то нужен рефакторинг, но
 в крайнем случае это должно выглядеть так:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

very_long_variable_name.draw_line(
\end_layout

\begin_layout Plain Layout

	Point{p1_x, p1_y},
\end_layout

\begin_layout Plain Layout

	Point{p2_x, p2_y});
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Исключения и ресурсы
\end_layout

\begin_layout Itemize
Слухи о низкой скорости исключений преувеличены, однако их частое использование
 накладывает нежелательный отпечаток на стиль программирования
\end_layout

\begin_layout Itemize
Исключения используются в местах, где игнорирование ошибки может привести
 к необратимому краху системы
\end_layout

\begin_layout Itemize
Такими ошибками обычно являются: некорректное взаимодействие с внешним
\begin_inset Foot
status open

\begin_layout Plain Layout
независимым от нашей системы
\end_layout

\end_inset

 ресурсом, неверное использование API-компонентов системы
\end_layout

\begin_layout Itemize
Однако, поводом для исключения не являются такие вещи, как: несоблюдение
 (пост/пре)условий при использовании внутреннего для системы компонента;
 также, эти условия не нужно задавать assert'ами внутри компонентов, но
 использовать concepts
\begin_inset Foot
status open

\begin_layout Plain Layout
будут введены в стандарте C++17 или позднее
\end_layout

\end_inset

 и систему типов(см.
 след.
 раздел о типах)
\end_layout

\begin_layout Itemize
throws/noexcept не используются, т.к.
 для большинства систем его польза сомнительна, тяжело поддерживать консистентно
сть, создаёт визуальный шум
\end_layout

\begin_layout Itemize
RAII где только возможно
\end_layout

\begin_layout Itemize
new/delete запрещены
\end_layout

\begin_layout Itemize
Не кидать исключения в деструкторах и т.п., а также являясь onwer'ом объекта/ресур
са
\end_layout

\begin_layout Chapter
Типы
\end_layout

\begin_layout Itemize
Предпочтение compile-time проверок исключениям
\end_layout

\begin_layout Itemize
T * t, T & t
\end_layout

\begin_layout Itemize
C-style массивы запрещены
\end_layout

\begin_layout Itemize
const везде, где только возможно
\begin_inset Foot
status open

\begin_layout Itemize
в привычку должна войти манера 
\begin_inset Quotes fld
\end_inset

убирать
\begin_inset Quotes frd
\end_inset

 препятствующие логике const-квалификаторы 
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
typedef не используется вообще в угоду читаемому using 
\end_layout

\begin_layout Itemize
Maybe<T> вместо nullable, return false или исключения для индикации большинства
 ошибок
\end_layout

\begin_layout Itemize
отсутствие 
\begin_inset Quotes fld
\end_inset

голых типов
\begin_inset Quotes frd
\end_inset

 в аргументах функций у API-методов и предпочтение им типизированных user-define
d literals, к примеру:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class KMs
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

	explicit KMs(unsigned long long int value)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		// ...
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	operator unsigned long long int()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Приведение типов используется только для ублажения компилятора при работе
 с 3rd party libs; если возможно, этот кошмар помещается в адаптер
\end_layout

\begin_layout Itemize
dynamic_cast нежелателен, т.к.
 зачастую означает code smell — рекомендуется пересмотреть дизайн
\end_layout

\begin_layout Itemize
Злоупотребление умными указателями отодвигает на задний план семантику передачи/
разделения ownership и неоправданно
\begin_inset Foot
status open

\begin_layout Plain Layout
проблемы с висячими указателями обнаруживаются компилятором и статическим
 анализатором
\end_layout

\end_inset

 снижает производительность; однако голые указатели в параметрах нужно оборачива
ть в обёртки, например:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

not_null<T*> check(T* p) { if (p) return not_null<T*>{p}; throw Unexpected_nullp
tr{}; } 
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Классы и функции
\end_layout

\begin_layout Itemize

\series bold
Single responsibility principle как основная движущая сила рефакторинга
\end_layout

\begin_layout Itemize
Длина функции/метода не более 25 строк
\end_layout

\begin_layout Itemize
Общая длина определения класса не более 150 строк
\begin_inset Foot
status open

\begin_layout Plain Layout
соблюдение этого правила очень важно, т.к.
 оно способствует читаемости и чистоте дизайна
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Синглтоны в любом виде и mutable глобальные переменные запрещены
\end_layout

\begin_layout Itemize
Классы, содержащие в названии туманные термины, ассоциирующиеся с программной
 архитектурой, такие как Interface, Model System(за исключением тех, что
 общаются с ОС и устройствами), Manager, Director, Factory, Controller и
 т.п.
 
\series bold
запрещены
\begin_inset Foot
status open

\begin_layout Plain Layout
да, в системных проектах тоже
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Имена классов начинаются с прописной буквы и используют camelcase: MessageReceiv
er, ArtificalObject и т.п.
\end_layout

\begin_layout Itemize
Имена функций и переменных начинаются со строчной буквы и используют snake_case:
 updated_message, start_recording() и т.п.
\end_layout

\begin_layout Itemize
Имена классовых переменных заканчиваются подчёркиванием: storage_, id_ и
 т.п.
\end_layout

\begin_layout Itemize
Квалификаторы доступа в классе не повторяются, идут сверху вниз в порядке
 public-proteced-private
\end_layout

\begin_layout Itemize
Внутри квалифицированных блоков сначала идут типы и спец.
 методы, потом методы, затем поля
\end_layout

\begin_layout Itemize
Методы, не изменяющие состояния класса, должны отмечаться как const
\end_layout

\begin_layout Itemize
Не стоит бояться virtual, однако предпочитать tag dispatch, CRTP и т.п.
\end_layout

\begin_layout Itemize
Иногда public метод можно заменить helper'ом
\end_layout

\begin_layout Itemize
Rule of zero, либо объявляем 
\series bold
все 
\series default
специальные функции, либо =delete 
\series bold
все 
\series default
специальные функции
\end_layout

\begin_layout Itemize
In-class member initializers улучшают читаемость
\end_layout

\begin_layout Itemize
Тривиальные (г/с)еттеры кошмарны
\end_layout

\begin_layout Itemize
Для симметричных операторов типа operator== используются free функции
\end_layout

\begin_layout Chapter
Наследование
\end_layout

\begin_layout Itemize
Разрешено наследование одной реализации
\begin_inset Foot
status open

\begin_layout Plain Layout
но лучше обходиться без него вообще; вертикальные иерархии - code smell
\end_layout

\end_inset

 и любого числа интерфейсов
\end_layout

\begin_layout Itemize
Composition over inheritance
\end_layout

\begin_layout Itemize
virtual метод не должен иметь default аргументов
\end_layout

\begin_layout Itemize
Все базовые классы должны иметь virtual деструктор
\begin_inset Foot
status open

\begin_layout Plain Layout
иначе undefined behavior, конечно
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Шаблоны
\end_layout

\begin_layout Itemize
Трюки с шаблонами должны повышать читаемость и экспрессивность, а не заглушать
 intention из-за premature optimization
\begin_inset Foot
status open

\begin_layout Plain Layout
в идеале она и не возникнет, т.к.
 её появление — сигнал о том, что TDD оказался заброшен, либо используются
 слишком большие шаги в TDD-цикле
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Шаблонные классы, определяющие новые virtual методы, запрещены
\end_layout

\begin_layout Itemize
tuple предпочтительнее pair из-за редкой нужды в обозначении семантики последней
\end_layout

\begin_layout Itemize
Шаблонные типы должны иметь максимум ограничений
\end_layout

\begin_layout Itemize
Все методы и типы класса, зависящие не от всех шаблонных аргументов, должны
 помещаться в базовый класс без шаблонов
\end_layout

\begin_layout Chapter
Агрегированный пример
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Person
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

public:
\end_layout

\begin_layout Plain Layout

	void say(const std::string & phrase)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//...
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	const std::string name_;
\end_layout

\begin_layout Plain Layout

private:
\end_layout

\begin_layout Plain Layout

	void think()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//...
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	std::unordered_map<int, int> thoughts_;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
